# A3.2 Relationship Querying Implementation

## Overview

Phase A3.2 implements comprehensive relationship querying capabilities for the Planning Center SDK's Fluent API. This enhancement enables developers to work with related entities through deep includes, relationship filtering, and relationship counting operations.

## Features Implemented

### 1. Deep Relationship Includes

#### Single Deep Include
```csharp
// Include nested relationships
var people = await client.People
    .IncludeDeep("households.members")
    .ExecuteAsync();
```

#### Multiple Deep Includes
```csharp
// Include multiple nested relationships
var people = await client.People
    .IncludeDeep("households.members", "field_data.field_definition", "emails")
    .ExecuteAsync();
```

#### LINQ Expression Includes
```csharp
// Type-safe includes using LINQ expressions
var people = await client.People
    .Include(p => p.Households)
    .Include(p => p.FieldData)
    .ExecuteAsync();
```

### 2. Relationship Filtering

#### Existence Filtering
```csharp
// Find people who have households
var peopleWithHouseholds = await client.People
    .WhereHasRelationship("households")
    .ExecuteAsync();

// Find people who don't have households
var peopleWithoutHouseholds = await client.People
    .WhereDoesntHaveRelationship("households")
    .ExecuteAsync();
```

#### Conditional Relationship Filtering
```csharp
// Find people with households named "Smith Family"
var smithFamilyMembers = await client.People
    .WhereHas("households", "name", "Smith Family")
    .ExecuteAsync();

// Find people with multiple household conditions
var result = await client.People
    .WhereHas("households", new Dictionary<string, object>
    {
        { "name", "Smith Family" },
        { "primary_contact_name", "John Smith" },
        { "member_count", 4 }
    })
    .ExecuteAsync();
```

### 3. Relationship Counting

#### Exact Count
```csharp
// Find people with exactly 2 households
var peopleWithTwoHouseholds = await client.People
    .WhereRelationshipCount("households", 2)
    .ExecuteAsync();
```

#### Range-based Counting
```csharp
// Find people with more than 1 household
var peopleWithMultipleHouseholds = await client.People
    .WhereRelationshipCountGreaterThan("households", 1)
    .ExecuteAsync();

// Find people with fewer than 5 emails
var peopleWithFewEmails = await client.People
    .WhereRelationshipCountLessThan("emails", 5)
    .ExecuteAsync();

// Find people with 2-5 households
var peopleInRange = await client.People
    .WhereRelationshipCountBetween("households", 2, 5)
    .ExecuteAsync();
```

## Technical Implementation

### Core Components

1. **IFluentQueryBuilder Interface** (`src/PlanningCenter.Api.Client/Fluent/IFluentQueryBuilder.cs`)
   - Added relationship querying method signatures
   - Comprehensive XML documentation
   - Support for method chaining

2. **FluentQueryBuilder Class** (`src/PlanningCenter.Api.Client/Fluent/QueryBuilder/FluentQueryBuilder.cs`)
   - Concrete implementation of relationship querying methods
   - Expression parsing for type-safe includes
   - Parameter building for API calls

3. **FluentQueryBuilderBase Class** (`src/PlanningCenter.Api.Client/Fluent/FluentQueryBuilderBase.cs`)
   - Base implementation for all fluent contexts
   - Virtual methods for customization
   - Parameter management and copying

### New Methods Added

#### Include Methods
- `Include<TProperty>(Expression<Func<T, TProperty>> include)` - Type-safe LINQ expression includes
- `IncludeDeep(string relationshipPath)` - Single deep relationship include
- `IncludeDeep(params string[] relationshipPaths)` - Multiple deep relationship includes

#### Relationship Existence Methods
- `WhereHasRelationship(string relationshipName)` - Filter by relationship existence
- `WhereDoesntHaveRelationship(string relationshipName)` - Filter by relationship absence

#### Relationship Condition Methods
- `WhereHas(string relationshipName, string field, object value)` - Single condition filtering
- `WhereHas(string relationshipName, Dictionary<string, object> filters)` - Multiple condition filtering

#### Relationship Counting Methods
- `WhereRelationshipCount(string relationshipName, int count)` - Exact count filtering
- `WhereRelationshipCountGreaterThan(string relationshipName, int minCount)` - Minimum count filtering
- `WhereRelationshipCountLessThan(string relationshipName, int maxCount)` - Maximum count filtering
- `WhereRelationshipCountBetween(string relationshipName, int minCount, int maxCount)` - Range count filtering

## API Parameter Generation

### Deep Includes
Deep relationship paths are added to the `include` parameter:
```
include=households.members,field_data.field_definition
```

### Relationship Existence
Relationship existence is filtered using `has_` prefixed parameters:
```
where[has_households]=true
where[has_emails]=false
```

### Relationship Conditions
Relationship conditions use dot notation:
```
where[households.name]=Smith Family
where[households.primary_contact_name]=John Smith
```

### Relationship Counting
Relationship counts use `_count` suffixed parameters:
```
where[households_count]=2
where[emails_count]=>0
where[households_count]=2..5
```

## Error Handling

### Input Validation
- Null/empty relationship names throw `ArgumentException`
- Null/empty field names throw `ArgumentException`
- Negative counts throw `ArgumentException`
- Invalid count ranges throw `ArgumentException`

### Example Error Cases
```csharp
// These will throw ArgumentException
_queryBuilder.WhereHasRelationship(""); // Empty relationship name
_queryBuilder.WhereHas("households", null, "value"); // Null field name
_queryBuilder.WhereRelationshipCount("households", -1); // Negative count
_queryBuilder.WhereRelationshipCountBetween("households", 5, 2); // Invalid range
```

## Testing

### Unit Tests
Comprehensive unit tests in `FluentQueryBuilderTests.cs` cover:
- Deep include functionality
- Relationship existence filtering
- Relationship condition filtering
- Relationship counting operations
- Error handling scenarios
- Method chaining combinations

### Test Coverage
- ✅ Single and multiple deep includes
- ✅ Relationship existence/absence filtering
- ✅ Single and multiple condition filtering
- ✅ All relationship counting operations
- ✅ Input validation and error handling
- ✅ Complex chained query scenarios

## Usage Examples

### Complex Relationship Query
```csharp
var complexQuery = await client.People
    .IncludeDeep("households.members", "field_data.field_definition")
    .WhereHasRelationship("households")
    .WhereHas("households", "name", "Smith Family")
    .WhereRelationshipCountGreaterThan("emails", 0)
    .WhereRelationshipCountBetween("phone_numbers", 1, 3)
    .Take(50)
    .ExecuteAsync();
```

### Household Management
```csharp
// Find all people in active households with more than 2 members
var activeFamilyMembers = await client.People
    .IncludeDeep("households.members")
    .WhereHas("households", new Dictionary<string, object>
    {
        { "status", "active" },
        { "member_count", ">2" }
    })
    .ExecuteAsync();
```

### Contact Information Analysis
```csharp
// Find people with complete contact information
var completeContacts = await client.People
    .WhereRelationshipCountGreaterThan("emails", 0)
    .WhereRelationshipCountGreaterThan("phone_numbers", 0)
    .WhereHasRelationship("addresses")
    .ExecuteAsync();
```

## Performance Considerations

### Query Optimization
- Deep includes are processed efficiently through the existing include mechanism
- Relationship filters are converted to appropriate API parameters
- Caching is maintained for expression parsing

### Best Practices
- Use specific relationship names to avoid ambiguity
- Combine relationship filters with other conditions for optimal performance
- Limit deep includes to necessary relationships only
- Use relationship counting for efficient filtering without loading related data

## Integration with Existing Features

### Compatibility
- All relationship querying methods work seamlessly with existing filtering
- Method chaining is fully supported
- Expression parsing integration maintains performance benefits
- Existing fluent contexts automatically inherit new capabilities

### Fluent Context Support
All fluent contexts (People, Calendar, Giving, etc.) automatically support:
- Deep relationship includes
- Relationship existence filtering
- Relationship condition filtering
- Relationship counting operations

## Future Enhancements

Potential areas for future development:
- Advanced relationship aggregation (SUM, AVG, etc.)
- Nested relationship condition builders
- Relationship-specific sorting options
- Performance optimization for complex relationship queries

## Conclusion

Phase A3.2 successfully implements comprehensive relationship querying capabilities, providing developers with powerful tools to work with related entities in the Planning Center API. The implementation maintains consistency with existing patterns while adding significant new functionality for complex data relationships.